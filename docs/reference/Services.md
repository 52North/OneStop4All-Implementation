# Services

Services are application components that implement one or more interfaces.
Service instances are created automatically by the framework when required,
and their dependencies will automatically be resolved prior to their construction.

## Declaring a service

A service is declared as a simple JavaScript class:

```ts
// some-package/HelloWorldService.ts
export class HelloWorldService {
    sayHello() {
        console.info("hello!");
    }
}
```

Services are not discovered automatically; they must be declared in the package's `build.config.mjs`:

```js
// some-package/build.config.mjs
import { defineBuildConfig } from "@open-pioneer/build-support";
export default defineBuildConfig({
    services: {
        // (1)
        HelloWorldService: {
            provides: "hello.HelloWorldService"
        }
    }
});
```

A matching export using the same name (see _(1)_) must be provided from `services.ts` or (`.js`).
The framework will try to import the class from that file:

```js
// some-package/services.ts
// The export name here must match the service name in the build.config.js.
// The actual class name in the source code does not matter.
// The class could also be defined in this module instead of importing it from a different file.
export { HelloWorldService } from "./HelloWorldService";
```

## Configuring a service

Services accept configuration options such as the interfaces they provide and the references they require.
These options are provided by editing the `build.config.mjs` of the containing package, see [Package Reference](./Package.md).

### Using a service from another service

Services can depend on other services by referencing an interface name.

```js
// sample-app/build.config.mjs
import { defineBuildConfig } from "@open-pioneer/build-support";
export default defineBuildConfig({
    services: {
        HelloWorldConsumer: {
            references: {
                // (1)
                helloWorldService: "hello.HelloWorldService"
            }
            // provides: ...
        }
    }
});
```

If the reference can be satisfied, the service implementing that interface name will automatically be injected by the framework into the other service's constructor (in `serviceOptions.references`). The reference name in the other service's constructor matches the name of the reference in _(1)_:

```js
// sample-app/services.js
export class HelloWorldConsumer {
    constructor(serviceOptions) {
        const references = serviceOptions.references;
        const service = references.helloWorldService;
        service.sayHello();
    }
}
```

References are either injected as an object (direct reference, the service that provides the interface)
or as an array (when multiple services are requested).
See documentation and examples in [Package Reference](./Package.md) for more details.

If a reference cannot be satisfied, the application will refuse to start with a detailed error message.

### Using a service from the UI

Services can also be used directly from react components.
Just like services, the UI must declare its dependencies before it can reference any service:

```js
// sample-app/build.config.mjs
export default defineBuildConfig({
    ui: {
        references: ["hello.HelloWorldService"]
    }
});
```

The snippet above tells the system that React components from the package `sample-app` may reference the service implementing `"hello.HelloWorldService"`.
The framework will ensure that that service is started, or that an error is thrown if no service provides that interface.

From within the React component, the `useService` hook can be used to reference the service:

```jsx
// sample-app/ExampleComponent.jsx
import { useService } from "open-pioneer:react-hooks";
import { useEffect } from "react";

function ExampleComponent() {
    const service = useService("hello.HelloWorldService");
    useEffect(() => {
        service.sayHello();
    }, []);
    return <div>This components calls service.sayHello after mounting</div>;
}
```

### Reference all services that provide a certain interface

It is possible to gather all services that provide a certain interface name by specifying `all: true` in the `build.config.mjs`.
The services are gathered and available as an array in the referencing service or UI.

An example is shown in [How To Create a Service Tutorial](../tutorials/HowToCreateAService.md).

See documentation and examples in [Package Reference](./Package.md) for more details.

## Service Options

The service constructor accepts a single object (`serviceOptions` in the example below).
This object is generated by the framework:

```js
// MyService.js
export class MyService {
    constructor(serviceOptions) {
        console.log(serviceOptions);
    }
}
```

The following values are available as properties of `serviceOptions`:

-   `references`: An object containing references to other services (as defined in the `build.config.mjs`).
-   `referencesMeta`: Metadata about references, uses the same names as `references`.
-   `properties`: An object containing the current package's properties (default values from `build.config.mjs`, possibly modified/overwritten by the application).
-   `intl`: The current package's `intl` object to support translations and formatting in the user's locale (see [I18N Format](./I18nFormat.md)).

<!-- TODO: Link to hosted api documentation ?? -->

Detailed documentation of `serviceOptions` is available in the API documentation of `@open-pioneer/runtime` (type `ServiceOptions`).

## Service start and stop behavior

Services are started when the application launches, i.e. when the application's DOM element has been mounted.
All services used by an app are started before the UI is rendered for the first time.

A service is considered "used" if it is needed by the UI (see `ui.references` in `build.config.mjs`),
if it defines an API on the application (provides `integration.ApiExtension`) or if it provides `runtime.AutoStart`.
The framework will take care to start all those services (and their dependencies) in the correct order.

The service start algorithm for a service `S` that depends on (`references`) two other services `D1` and `D2`
is as follows:

1. Recursively create `D1` and `D2`.
2. Invoke the constructor of `S` (passing references to `D1` and `D2`).

Creating the dependencies before `S` ensures that `S` always sees a fully initialized version of its dependencies.

Service destruction happens when the application is destroyed, i.e. when the DOM element gets unmounted.
It reverses the construction algorithm:

1. Destroy `S` if it is no longer being referenced by invoking the `destroy()` method.
2. Recursively destroy `D1` and `D2`.

Dependencies are destroyed after their dependents to ensure that their instances are still valid in the `destroy()` method of `S`.

> NOTE:
> Reference cycles between services are forbidden: the app will refuse to launch.
> This can often be worked around by fixing the design: common functionality needs to move to a shared service.
> In the future, we could consider implementing lazy references (see [Internal Documentation](../internals/ServiceLayer.md)).

## Overriding services

Applications can override services from other packages, see [Reference](./Package.md#overrides).

## TypeScript Integration

It is recommended, but not required, to author all services in TypeScript.
The runtime provides a few facilities to aid with the implementation.

The `Service` interface provides types for the service's lifecycle methods.
At the time of this writing this is just `destroy()`, but more methods may be added in the future.
It also accepts an optional type parameter representing the service's public API.
The properties and methods from the type are merged with the service's lifecycle methods:

```ts
// ExampleService.ts
import { Service } from "@open-pioneer/runtime";

// The ./api file contains the public interface
import { MyService } from "./api";

// The Impl class implements Service<MyService>, i.e. the optional
// lifecycle methods and the methods and properties defined by `MyService`.
export class MyServiceImpl implements Service<MyService> {
    // ... methods
}
```

The `ServiceOptions` type is helpful when typing a service's constructor parameters.
It accepts an optional `References` type parameter with the types of the expected references, for example:

```ts
// ExampleService.ts
import { Service, ServiceOptions } from "@open-pioneer/runtime";
import { MyService } from "./api";
import { SomeRefType } from "otherPackage/api";

interface References {
    // someRef is actually declared in the build.config.mjs,
    // but we tell TypeScript which type to expect.
    someRef: SomeRefType;
}

export class MyServiceImpl implements Service<MyService> {
    constructor(options: ServiceOptions<References>) {
        const someRef = options.references.someRef; // of type SomeRefType, no compiler error
    }

    // ... methods
}
```

### Registering service interfaces

An interface name can be associated with TypeScript interfaces, which greatly improves the developer experience when interacting with services.

In order to provide a type for an interface name, extent the `ServiceRegistry` interface.
This is usually done from a file called `api.ts` or `api/index.ts`:

```ts
// somePackage/api.ts

/** All implementations of `"hello.HelloWorldService"` must conform to this interface. */
export interface HelloWorldService {
    /** Says hello. */
    sayHello(): void;
}

// This uses a typescript feature called "declaration merging".
// All packages can (optionally) associate interface names with their typescript types.
// See also https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-interfaces
import "@open-pioneer/runtime";
declare module "@open-pioneer/runtime" {
    interface ServiceRegistry {
        "hello.HelloWorldService": HelloWorldService;
    }
}
```

The declaration above tells the compiler that whenever the interface `"hello.HelloWorldService"` is required, that the returned object conforms to the `interface HelloWorldService`.

That information can be used like this:

-   Using the `useService` hook:

    ```jsx
    // ExampleComponent.tsx
    function ExampleComponent() {
        // Of type HelloWorldService, or `unknown` if no type has been registered.
        const service = useService("hello.HelloWorldService");
    }
    ```

-   Using the `ServiceType` helper directly:

    ```ts
    // ExampleService.ts
    import { Service, ServiceType } from "@open-pioneer/runtime";

    interface References {
        // Automatically resolves to the registered type
        // or compilation fails if no type has been registered.
        helloWorldService: ServiceType<"hello.HelloWorldService">;
    }

    class ExampleService implements Service {
        constructor(options: ServiceOptions<References>) {}
    }
    ```

### Registering package properties

A similar machinery can be used to declare properties (and their) types of the current package:

```ts
// some-package/api.ts

export interface LoggingProperties {
    /** Log level for the shared logger. */
    logLevel: "DEBUG" | "INFO" | "ERROR";
}

import "@open-pioneer/runtime";
declare module "@open-pioneer/runtime" {
    interface PropertiesRegistry {
        // Associates the package name with the given interface for its property types.
        "some-package": Partial<LoggingProperties>;
    }
}
```
